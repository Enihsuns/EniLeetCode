# 15 3Sum

## 1_190313
-1 0 1 2 -1 -4

先排序：-4 -1 -1 0 1 2

由于我们想要sum up to 0，所以必定包含正数和负数。可以用3个pointers begin end mid。Left从左到右，right从右到左，mid则从left到right之间，使用二分法查找有没有满足条件的值。移动的策略是根据left+right的和为正还是负。

啊 愚蠢

Testcase 1:
Input
[-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6]

Output
[[-4,-2,6],[-4,0,4],[-4,1,3],[-2,0,2]]

Expected
[[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2],[-2,-2,4],[-2,0,2]]

错误原因：终于意识到了之前的思考方式有问题，就是说，不一定left+right为负的话，就一定要往右边移。比方说，[-4, 2, 2]就是尽管-4+2<0，还是可以有解。总的来说就是O(n)扫一遍肯定是不行的。考虑一下别的方法。

然后我用了双层循环+中间二分查找。


Testcase 2:
Input
[0, 0]

Output
[[0, 0, 0]]

Expected
[]

错误原因：没有检查nums的大小，以及在移动指针的时候没有考虑范围，以及binarySearch的时候没有判断范围。

## 2_190313
啊总之就是把3Sum转成2Sum来做。先排序。遍历每个element, 遍历的时候就fix那个element，只对排在它后面的elements做2Sum。

需要注意的地方就是在遍历和2Sum的过程中，要跳过相同的element。

本来想用map写2Sum，遇到了尴尬的问题：在2Sum问题里面，array里面的int是distinct的，也就是说，永远都不会存在有重复的element这种情况。但是在3Sum里面，存在着重复的element，并且要求输出不重复的答案。在testcase中，有两类很容易卡死我：
	1. [-4, 2, 2]这类，使用了重复的元素的。
	2. [0, 0, 0, 0, 0]这类，既使用了重复的元素，又要求答案不重复。
就很烦烦呀。不能单纯地用Idx来判断，也不能用Nums[idx]是否等于nums[j]来判断。所以说，别用**map**。

最后还是借鉴一番排名前面的答案，使用two pointers，左移，右移。这个时候我们就可以根据当前两个Pointers之间的和来判断移左边还是右边辣。