# 50 Pow(x, n)
Medium

> 参考https://www.kancloud.cn/kancloud/data-structure-and-algorithm-notes/72989

## My thoughts
没有想法。数学题。不会写。

## 1_190508
参考答案，使用Fast Power Algorithm。

(a * b) % p = ((a % p) * (b % p)) % p

也就是a与b的乘积模p等于a与b分别模p相乘之后再模p。

所以我们可以递归地改写

$$x^n = x^(n/2) * x^(n/2)$$

在这个里面有一个问题是，有的时候n/2不一定能整除。可能n会是一个奇数。如果n是奇数，我们需要多乘一个x。

另一个需要注意的地方是，n可能为奇数。这样的话，我们只需要对x取倒数，再对n取绝对值就可以啦。

Test case 1:
Input: 2.00000<br>
-2147483648<br>
Output: 1.0<br>
Expected: 0.0<br>

错误原因：n小于零，然后对n取绝对值，然后就0了因为超出了正数表达的上界。看了一下答案的解决办法...就是用**long long**来存n。这样就不会超出上界了。。。好的我记住了。

## 2_190508
看了一下，runtime只击败了72.35%。欣赏一下排在前面的代码。发现他们有如下几个优化：
1. 首先，没有写两个方法，而是只写了一个myPow自己调用自己。
2. 对于n < 0的情况，他们没有像我前面一样为了取好绝对值而转成long，而是n = (int)(Math.abs(n + 1))，也就是取n+1的绝对值。这样有一个好处就是避开了超出上界的情况。当然，为了补偿这个+1，返回的结果需要乘上一个多的1/x。